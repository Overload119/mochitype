# typed: true
# frozen_string_literal: true

module Mochitype
  class ReflectionTypeConverter
    extend T::Sig

    SORBET_TYPESCRIPT_MAPPING = {
      String => 'z.string()',
      Integer => 'z.number()',
      Float => 'z.number()',
      Numeric => 'z.number()',
    }

    sig { params(file_path: String).void }
    def initialize(file_path)
      @file_path = file_path
    end

    # Entrypoint to generate the Typescript file content from the main struct that's being converted.
    sig { returns(String) }
    def build_typescript_file
      buffer = String.new("/**\n")
      buffer << "/* This file is generated by Mochitype. Do not edit it by hand.\n"
      buffer << "/**/\n\n"
      buffer << "import { z } from 'zod';\n\n"

      buffer << convertible_class_to_typescript(root_convertible_class)
      buffer.strip!
      buffer << "\n"
    end

    sig { params(convertible_class: ConvertibleClass).returns(String) }
    def convertible_class_to_typescript(convertible_class)
      buffer = String.new

      if convertible_class.klass < T::Enum
        values = T.unsafe(convertible_class.klass).values.map(&:serialize).map { "'#{_1}'" }
        buffer << "export const #{convertible_class.typescript_name} = z.enum([#{values.join(', ')}]);\n\n"
      elsif convertible_class.klass < T::Struct
        # Populate the properties.
        properties = {}
        inner_classes = T.let([], T::Array[ConvertibleClass])
        T
          .cast(convertible_class.klass, T.class_of(T::Struct))
          .props
          .each do |property_name, data|
            convertible_property = write_prop(data)
            properties[property_name.to_s] = convertible_property.zod_definition
            inner_classes +=
              convertible_property.discovered_classes.map do |klass|
                ConvertibleClass.new(klass: klass)
              end
          end

        convertible_class.props = properties
        convertible_class.inner_classes = inner_classes

        # Before adding this convertible class into the TypeScript file, we have to make sure all of
        # its dependencies are added first.
        convertible_class.inner_classes.each do |inner_class|
          buffer << convertible_class_to_typescript(inner_class)
        end

        buffer << "export const #{convertible_class.typescript_name} = z.object({\n"
        buffer << convertible_class.props.map { |name, type| "  #{name}: #{type}" }.join(",\n")
        buffer << "\n});\n\n"
      else
        raise NotImplementedError, "Unknown type: #{convertible_class.klass}"
      end

      buffer << "export type #{convertible_class.typescript_type_name} = z.infer<typeof #{convertible_class.typescript_name}>;\n\n"
      buffer
    end

    sig { returns(ConvertibleClass) }
    def root_convertible_class
      klass_name = extract_main_klass
      klass = klass_name.constantize
      
      # Accept both T::Struct and T::Enum
      unless (klass.is_a?(Class) && (klass < T::Struct || klass < T::Enum))
        raise TypeError, "Expected T::Struct or T::Enum, got #{klass}"
      end

      ConvertibleClass.new(klass: klass)
    end

    # Computes the Typescript-property of a T::Struct.
    # @param data A `const` or `prop` property definition from a T::Struct.
    sig { params(data: T::Hash[Symbol, T.untyped]).returns(ConvertibleProperty) }
    def write_prop(data)
      is_nilable = data[:_tnilable]
      
      result = case data[:type].class.to_s
      # Handle special Sorbet types that should map to z.unknown()
      when 'T::Types::Untyped'
        ConvertibleProperty.new(zod_definition: 'z.unknown()', discovered_classes: [])
      when 'T::Types::Intersection'
        # T.all - intersection types are not representable in Zod
        ConvertibleProperty.new(zod_definition: 'z.unknown()', discovered_classes: [])
      when 'T::Types::ClassOf'
        # T.class_of - represents a class itself, not an instance
        ConvertibleProperty.new(zod_definition: 'z.unknown()', discovered_classes: [])
      when 'T::Types::AttachedClass'
        # T.attached_class - used in module mixins
        ConvertibleProperty.new(zod_definition: 'z.unknown()', discovered_classes: [])
      when 'T::Types::NoReturn'
        # T.noreturn - function never returns
        ConvertibleProperty.new(zod_definition: 'z.unknown()', discovered_classes: [])
      when 'T::Types::TypedArray', 'T::Types::TypedArray::Untyped'
        inner_type = data[:type].type
        inner_type_convertible_property = instance_of_class_to_convertible_property(inner_type)

        ConvertibleProperty.new(
          zod_definition: "z.array(#{inner_type_convertible_property.zod_definition})",
          discovered_classes: inner_type_convertible_property.discovered_classes,
        )
      when 'T::Private::Types::SimplePairUnion'
        first_value = data[:type].types[0].raw_type
        second_value = data[:type].types[1].raw_type
        if [first_value, second_value].to_set == [TrueClass, FalseClass].to_set
          ConvertibleProperty.new(zod_definition: 'z.boolean()', discovered_classes: [])
        else
          fv = simple_class_to_typescript(first_value)
          sv = simple_class_to_typescript(second_value)

          ConvertibleProperty.new(
            zod_definition: "z.union([#{fv.zod_definition}, #{sv.zod_definition}])",
            discovered_classes: (fv.discovered_classes + sv.discovered_classes).uniq,
          )
        end
      when 'T::Types::TypedHash'
        key_type = data[:type].keys
        value_type = data[:type].values

        key_convertible_property = instance_of_class_to_convertible_property(key_type)
        value_convertible_property = instance_of_class_to_convertible_property(value_type)

        ConvertibleProperty.new(
          zod_definition:
            "z.record(#{key_convertible_property.zod_definition}, #{value_convertible_property.zod_definition})",
          discovered_classes: [],
        )
      when 'T::Types::Union'
        union_types = data[:type].types.map(&:raw_type)
        properties = union_types.map { |union_type| simple_class_to_typescript(union_type) }

        values = properties.map(&:zod_definition)
        discovered_classes = properties.flat_map(&:discovered_classes).uniq

        ConvertibleProperty.new(
          zod_definition: "z.union([#{values.join(',')}])",
          discovered_classes: discovered_classes,
        )
      else
        simple_class_to_typescript(data[:type])
      end

      # Add .nullable() if the type is nilable
      if is_nilable
        ConvertibleProperty.new(
          zod_definition: "#{result.zod_definition}.nullable()",
          discovered_classes: result.discovered_classes
        )
      else
        result
      end
    end

    sig { params(instance: T.untyped).returns(ConvertibleProperty) }
    def instance_of_class_to_convertible_property(instance)
      # Handle special Sorbet types
      case instance.class.to_s
      when 'T::Types::Untyped'
        return ConvertibleProperty.new(zod_definition: 'z.unknown()', discovered_classes: [])
      when 'T::Types::Intersection'
        return ConvertibleProperty.new(zod_definition: 'z.unknown()', discovered_classes: [])
      when 'T::Types::ClassOf'
        return ConvertibleProperty.new(zod_definition: 'z.unknown()', discovered_classes: [])
      when 'T::Types::AttachedClass'
        return ConvertibleProperty.new(zod_definition: 'z.unknown()', discovered_classes: [])
      when 'T::Types::NoReturn'
        return ConvertibleProperty.new(zod_definition: 'z.unknown()', discovered_classes: [])
      end

      if instance.is_a?(T::Types::Simple)
        simple_class_to_typescript(instance.raw_type)
      elsif instance.is_a?(T::Types::TypedArray)
        inner_type = instance.type
        inner_type_convertible_property = instance_of_class_to_convertible_property(inner_type)

        ConvertibleProperty.new(
          zod_definition: "z.array(#{inner_type_convertible_property.zod_definition})",
          discovered_classes: inner_type_convertible_property.discovered_classes,
        )
      elsif instance.is_a?(T::Types::TypedHash)
        key_type = instance.keys
        value_type = instance.values

        key_convertible_property = instance_of_class_to_convertible_property(key_type)
        value_convertible_property = instance_of_class_to_convertible_property(value_type)

        ConvertibleProperty.new(
          zod_definition:
            "z.record(#{key_convertible_property.zod_definition}, #{value_convertible_property.zod_definition})",
          discovered_classes: [],
        )
      elsif instance.is_a?(T::Types::Union)
        union_types = instance.types.map(&:raw_type)
        if union_types.to_set == [TrueClass, FalseClass].to_set
          ConvertibleProperty.new(zod_definition: 'z.boolean()', discovered_classes: [])
        else
          properties = union_types.map { |union_type| simple_class_to_typescript(union_type) }
          values = properties.map(&:zod_definition)
          discovered_classes = properties.flat_map(&:discovered_classes).uniq

          ConvertibleProperty.new(
            zod_definition: "z.union([#{values.join(', ')}])",
            discovered_classes: discovered_classes,
          )
        end
      else
        ConvertibleProperty.new(zod_definition: 'z.unknown()')
      end
    end

    sig { params(klass: T.untyped).returns(ConvertibleProperty) }
    def simple_class_to_typescript(klass)
      # Check if klass is a Class first, since < operator only works on classes
      if klass.is_a?(Class)
        case
        when klass < T::Struct
          inner_klass = ConvertibleClass.new(klass: klass)
          ConvertibleProperty.new(
            zod_definition: inner_klass.typescript_name,
            discovered_classes: [klass],
          )
        when klass < T::Enum
          inner_klass = ConvertibleClass.new(klass: klass)
          ConvertibleProperty.new(
            zod_definition: inner_klass.typescript_name,
            discovered_classes: [klass],
          )
        when SORBET_TYPESCRIPT_MAPPING.key?(klass)
          ConvertibleProperty.new(zod_definition: SORBET_TYPESCRIPT_MAPPING[klass])
        else
          ConvertibleProperty.new(zod_definition: 'z.unknown()')
        end
      else
        ConvertibleProperty.new(zod_definition: 'z.unknown()')
      end
    end

    # Reads the primary class that is being converted.
    # @return a namespaced class name
    sig { returns(String) }
    def extract_main_klass
      ast = Prism.parse(File.read(@file_path))

      struct_class_name = T.let(nil, T.nilable(String))
      enum_class_name = T.let(nil, T.nilable(String))
      nodes_to_visit = ast.value.statements.body.dup
      module_names = []

      # Traverse and find classes - prefer T::Struct over T::Enum
      while node = nodes_to_visit.shift
        if node.is_a?(Prism::ModuleNode)
          module_names << node.name.to_s
        elsif node.is_a?(Prism::ClassNode)
          parent = node.superclass

          if parent.is_a?(Prism::ConstantPathNode)
            if parent.full_name == 'T::Struct'
              struct_class_name = node.name.to_s
              # Found a struct, stop searching since structs are preferred
              break
            elsif parent.full_name == 'T::Enum'
              # Keep track of enum but continue searching for a struct
              enum_class_name ||= node.name.to_s
            end
          end
        end

        nodes_to_visit.concat(node.child_nodes.compact)
      end

      # Prefer struct over enum
      class_name = struct_class_name || enum_class_name
      [*module_names, T.must(class_name)].compact.join('::')
    end
  end
end
