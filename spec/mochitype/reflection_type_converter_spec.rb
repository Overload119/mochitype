# frozen_string_literal: true

require 'spec_helper'

# Load test data
Dir.glob('./spec/test-data/*.rb').each { |filepath| require_relative filepath.sub('./spec/', '../') }

RSpec.describe Mochitype::ReflectionTypeConverter do
  let(:app_filepath) { './spec/test-data/app.rb' }
  let(:payload_filepath) { './spec/test-data/payload.rb' }

  describe '#initialize' do
    it 'accepts a file path' do
      converter = described_class.new(app_filepath)
      expect(converter).to be_a(described_class)
    end
  end

  describe '#extract_main_klass' do
    it 'extracts the main class name from a simple struct' do
      converter = described_class.new(app_filepath)
      expect(converter.extract_main_klass).to eq('App')
    end

    it 'extracts the main class name from a nested struct' do
      converter = described_class.new(payload_filepath)
      expect(converter.extract_main_klass).to eq('Payload')
    end
  end

  describe '#build_typescript_file' do
    it 'includes the generated file header' do
      converter = described_class.new(app_filepath)
      output = converter.build_typescript_file

      expect(output).to include('This file is generated by Mochitype')
      expect(output).to include('Do not edit it by hand')
    end

    it 'imports zod' do
      converter = described_class.new(app_filepath)
      output = converter.build_typescript_file

      expect(output).to include("import { z } from 'zod';")
    end

    it 'exports a schema constant' do
      converter = described_class.new(app_filepath)
      output = converter.build_typescript_file

      expect(output).to include('export const AppSchema')
    end

    it 'exports a type definition' do
      converter = described_class.new(app_filepath)
      output = converter.build_typescript_file

      expect(output).to match(/export type \w+ = z\.infer/)
    end

    it 'ends with a newline' do
      converter = described_class.new(app_filepath)
      output = converter.build_typescript_file

      expect(output).to end_with("\n")
    end
  end

  describe '#simple_class_to_typescript' do
    let(:converter) { described_class.new(app_filepath) }

    it 'converts String to z.string()' do
      result = converter.simple_class_to_typescript(String)
      expect(result.zod_definition).to eq('z.string()')
      expect(result.discovered_classes).to be_empty
    end

    it 'converts Integer to z.number()' do
      result = converter.simple_class_to_typescript(Integer)
      expect(result.zod_definition).to eq('z.number()')
      expect(result.discovered_classes).to be_empty
    end

    it 'converts Float to z.number()' do
      result = converter.simple_class_to_typescript(Float)
      expect(result.zod_definition).to eq('z.number()')
      expect(result.discovered_classes).to be_empty
    end

    it 'converts Numeric to z.number()' do
      result = converter.simple_class_to_typescript(Numeric)
      expect(result.zod_definition).to eq('z.number()')
      expect(result.discovered_classes).to be_empty
    end

    it 'converts unknown types to z.unknown()' do
      result = converter.simple_class_to_typescript(Object)
      expect(result.zod_definition).to eq('z.unknown()')
      expect(result.discovered_classes).to be_empty
    end

    it 'converts T::Struct to schema reference' do
      result = converter.simple_class_to_typescript(Payload::Result)
      expect(result.zod_definition).to eq('PayloadResultSchema')
      expect(result.discovered_classes).to include(Payload::Result)
    end

    it 'converts T::Enum to enum reference' do
      result = converter.simple_class_to_typescript(Payload::Result::ResultType)
      expect(result.zod_definition).to eq('PayloadResultResultTypeEnum')
      expect(result.discovered_classes).to include(Payload::Result::ResultType)
    end
  end

  describe '#convertible_class_to_typescript' do
    it 'handles T::Enum classes' do
      converter = described_class.new(payload_filepath)
      convertible = ConvertibleClass.new(klass: Payload::Result::ResultType)
      output = converter.convertible_class_to_typescript(convertible)

      expect(output).to include('export const PayloadResultResultTypeEnum = z.enum')
      expect(output).to include("'animal'")
      expect(output).to include("'plant'")
      expect(output).to include("'human'")
    end

    it 'handles T::Struct classes' do
      converter = described_class.new(app_filepath)
      convertible = ConvertibleClass.new(klass: App)
      output = converter.convertible_class_to_typescript(convertible)

      expect(output).to include('export const AppSchema = z.object')
    end

    it 'hoists inner classes before parent' do
      converter = described_class.new(payload_filepath)
      output = converter.build_typescript_file

      # Enum should come before Result, Result before Payload
      enum_pos = output.index('PayloadResultResultTypeEnum')
      result_pos = output.index('PayloadResultSchema')
      payload_pos = output.index('PayloadSchema')

      expect(enum_pos).to be < result_pos
      expect(result_pos).to be < payload_pos
    end
  end

  describe 'type conversions' do
    let(:converter) { described_class.new(app_filepath) }

    context 'with nullable types' do
      it 'handles nullable strings' do
        data = { type: String, _tnilable: true }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.string().nullable()')
      end

      it 'handles nullable numbers' do
        data = { type: Integer, _tnilable: true }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.number().nullable()')
      end
    end

    context 'with arrays' do
      it 'handles typed arrays' do
        data = { type: T::Types::TypedArray.new(String) }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.array(z.string())')
      end

      it 'handles arrays of custom types' do
        data = { type: T::Types::TypedArray.new(Payload::Result) }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.array(PayloadResultSchema)')
        expect(result.discovered_classes).to include(Payload::Result)
      end
    end

    context 'with unions' do
      it 'handles boolean unions (TrueClass | FalseClass)' do
        union_type = T::Private::Types::SimplePairUnion.new(
          T::Types::Simple.new(TrueClass),
          T::Types::Simple.new(FalseClass)
        )
        data = { type: union_type }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.boolean()')
      end

      it 'handles string | integer unions' do
        union_type = T::Private::Types::SimplePairUnion.new(
          T::Types::Simple.new(String),
          T::Types::Simple.new(Integer)
        )
        data = { type: union_type }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.union([z.string(), z.number()])')
      end
    end

    context 'with typed hashes' do
      it 'handles T::Hash[String, T.untyped]' do
        hash_type = T::Types::TypedHash.new(
          keys: T::Types::Simple.new(String),
          values: T::Types::Untyped.new
        )
        data = { type: hash_type }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.record(z.string(), z.unknown())')
      end
    end

    context 'with special Sorbet types' do
      it 'handles T.untyped' do
        data = { type: T::Types::Untyped.new }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.unknown()')
        expect(result.discovered_classes).to be_empty
      end

      it 'handles T.any (multi-type union)' do
        union_type = T::Types::Union.new([
          T::Types::Simple.new(String),
          T::Types::Simple.new(Integer),
          T::Types::Simple.new(Float),
          T::Types::Simple.new(Symbol)
        ])
        data = { type: union_type }
        result = converter.write_prop(data)
        # Should produce a union of the known types
        expect(result.zod_definition).to include('z.union')
      end

      it 'handles T.all (intersection type)' do
        intersection_type = T::Types::Intersection.new([
          T::Types::Simple.new(T::Struct),
          T::Types::Simple.new(Kernel)
        ])
        data = { type: intersection_type }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.unknown()')
        expect(result.discovered_classes).to be_empty
      end

      it 'handles T.class_of' do
        class_of_type = T::Types::ClassOf.new(String)
        data = { type: class_of_type }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.unknown()')
        expect(result.discovered_classes).to be_empty
      end

      xit 'handles T.attached_class' do
        # Skip: T::Types::AttachedClass might not be available in all Sorbet versions
        attached_type = T::Types::AttachedClass.new
        data = { type: attached_type }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.unknown()')
        expect(result.discovered_classes).to be_empty
      end

      it 'handles T.noreturn' do
        noreturn_type = T::Types::NoReturn.new
        data = { type: noreturn_type }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.unknown()')
        expect(result.discovered_classes).to be_empty
      end
    end
  end
end
