# frozen_string_literal: true

require 'spec_helper'

# Load test data
Dir
  .glob('./spec/test-data/*.rb')
  .each { |filepath| require_relative filepath.sub('./spec/', '../') }

RSpec.describe Mochitype::ReflectionTypeConverter do
  let(:app_filepath) { './spec/test-data/app.rb' }
  let(:payload_filepath) { './spec/test-data/payload.rb' }

  describe '#initialize' do
    it 'accepts a file path' do
      converter = described_class.new(app_filepath)
      expect(converter).to be_a(described_class)
    end
  end

  describe '#extract_main_klass' do
    it 'extracts the main class name from a simple struct' do
      converter = described_class.new(app_filepath)
      expect(converter.extract_main_klass).to eq('App')
    end

    it 'extracts the main class name from a nested struct' do
      converter = described_class.new(payload_filepath)
      expect(converter.extract_main_klass).to eq('Payload')
    end
  end

  describe '#build_typescript_file' do
    it 'includes the generated file header' do
      converter = described_class.new(app_filepath)
      output = converter.build_typescript_file

      expect(output).to include('This file is generated by Mochitype')
      expect(output).to include('Do not edit it by hand')
    end

    it 'imports zod' do
      converter = described_class.new(app_filepath)
      output = converter.build_typescript_file

      expect(output).to include("import { z } from 'zod';")
    end

    it 'exports a schema constant' do
      converter = described_class.new(app_filepath)
      output = converter.build_typescript_file

      expect(output).to include('export const App')
    end

    it 'exports a type definition' do
      converter = described_class.new(app_filepath)
      output = converter.build_typescript_file

      expect(output).to match(/export type \w+ = z\.infer/)
    end

    it 'ends with a newline' do
      converter = described_class.new(app_filepath)
      output = converter.build_typescript_file

      expect(output).to end_with("\n")
    end
  end

  describe '#simple_class_to_typescript' do
    let(:converter) { described_class.new(app_filepath) }

    it 'converts String to z.string()' do
      result = converter.simple_class_to_typescript(String)
      expect(result.zod_definition).to eq('z.string()')
      expect(result.discovered_classes).to be_empty
    end

    it 'converts Integer to z.number()' do
      result = converter.simple_class_to_typescript(Integer)
      expect(result.zod_definition).to eq('z.number()')
      expect(result.discovered_classes).to be_empty
    end

    it 'converts Float to z.number()' do
      result = converter.simple_class_to_typescript(Float)
      expect(result.zod_definition).to eq('z.number()')
      expect(result.discovered_classes).to be_empty
    end

    it 'converts Numeric to z.number()' do
      result = converter.simple_class_to_typescript(Numeric)
      expect(result.zod_definition).to eq('z.number()')
      expect(result.discovered_classes).to be_empty
    end

    it 'converts unknown types to z.unknown()' do
      result = converter.simple_class_to_typescript(Object)
      expect(result.zod_definition).to eq('z.unknown()')
      expect(result.discovered_classes).to be_empty
    end

    it 'converts T::Struct to schema reference' do
      result = converter.simple_class_to_typescript(Payload::Result)
      expect(result.zod_definition).to eq('Result')
      expect(result.discovered_classes).to include(Payload::Result)
    end

    it 'converts T::Enum to enum reference' do
      result = converter.simple_class_to_typescript(Payload::Result::ResultType)
      expect(result.zod_definition).to eq('ResultType')
      expect(result.discovered_classes).to include(Payload::Result::ResultType)
    end
  end

  describe '#convertible_class_to_typescript' do
    it 'handles T::Enum classes' do
      converter = described_class.new(payload_filepath)
      convertible = ConvertibleClass.new(klass: Payload::Result::ResultType)
      output = converter.convertible_class_to_typescript(convertible)

      expect(output).to include('export const ResultType = z.enum')
      expect(output).to include("'animal'")
      expect(output).to include("'plant'")
      expect(output).to include("'human'")
    end

    it 'handles T::Struct classes' do
      converter = described_class.new(app_filepath)
      convertible = ConvertibleClass.new(klass: App)
      output = converter.convertible_class_to_typescript(convertible)

      expect(output).to include('export const App = z.object')
    end

    it 'hoists inner classes before parent' do
      converter = described_class.new(payload_filepath)
      output = converter.build_typescript_file

      # Enum should come before Result, Result before Payload
      enum_pos = output.index('export const ResultType = z.enum')
      result_pos = output.index('export const Result = z.object')
      payload_pos = output.index('export const Payload = z.object')

      expect(enum_pos).to be < result_pos
      expect(result_pos).to be < payload_pos
    end

    it 'does not duplicate inner classes when referenced multiple times' do
      filepath = './spec/test-data/duplicate_nested_classes.rb'
      converter = described_class.new(filepath)
      output = converter.build_typescript_file

      # Count how many times UrlImageHash appears as an export
      url_image_hash_count = output.scan(/export const UrlImageHash = z\.object/).length
      expect(url_image_hash_count).to eq(1),
      "Expected UrlImageHash to be exported once, but found #{url_image_hash_count} times"

      # Count how many times ApplicationResearchArea appears as an export
      research_area_count = output.scan(/export const ApplicationResearchArea = z\.object/).length
      expect(research_area_count).to eq(1),
      "Expected ApplicationResearchArea to be exported once, but found #{research_area_count} times"

      # Verify the main class still references them correctly
      expect(output).to include('logo: UrlImageHash')
      expect(output).to include('banner_video: UrlImageHash')
      expect(output).to include('banner_image: UrlImageHash')
      expect(output).to include('research_areas: z.array(ApplicationResearchArea)')
      expect(output).to include('more_research_areas: z.array(ApplicationResearchArea)')
    end
  end

  describe 'type conversions' do
    let(:converter) { described_class.new(app_filepath) }

    context 'with nullable types' do
      it 'handles nullable strings' do
        data = { type: String, _tnilable: true }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.string().nullable()')
      end

      it 'handles nullable numbers' do
        data = { type: Integer, _tnilable: true }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.number().nullable()')
      end
    end

    context 'with arrays' do
      it 'handles typed arrays' do
        data = { type: T::Types::TypedArray.new(String) }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.array(z.string())')
      end

      it 'handles arrays of custom types' do
        data = { type: T::Types::TypedArray.new(Payload::Result) }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.array(Result)')
        expect(result.discovered_classes).to include(Payload::Result)
      end
    end

    context 'with unions' do
      it 'handles boolean unions (TrueClass | FalseClass)' do
        union_type =
          T::Private::Types::SimplePairUnion.new(
            T::Types::Simple.new(TrueClass),
            T::Types::Simple.new(FalseClass),
          )
        data = { type: union_type }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.boolean()')
      end

      it 'handles string | integer unions' do
        union_type =
          T::Private::Types::SimplePairUnion.new(
            T::Types::Simple.new(String),
            T::Types::Simple.new(Integer),
          )
        data = { type: union_type }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.union([z.string(), z.number()])')
      end
    end

    context 'with typed hashes' do
      it 'handles T::Hash[String, T.untyped]' do
        hash_type =
          T::Types::TypedHash.new(keys: T::Types::Simple.new(String), values: T::Types::Untyped.new)
        data = { type: hash_type }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.record(z.string(), z.unknown())')
      end
    end

    context 'with special Sorbet types' do
      it 'handles T.untyped' do
        data = { type: T::Types::Untyped.new }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.unknown()')
        expect(result.discovered_classes).to be_empty
      end

      it 'handles T.any (multi-type union)' do
        union_type =
          T::Types::Union.new(
            [
              T::Types::Simple.new(String),
              T::Types::Simple.new(Integer),
              T::Types::Simple.new(Float),
              T::Types::Simple.new(Symbol),
            ],
          )
        data = { type: union_type }
        result = converter.write_prop(data)
        # Should produce a union of the known types
        expect(result.zod_definition).to include('z.union')
      end

      it 'handles T.all (intersection type)' do
        intersection_type =
          T::Types::Intersection.new(
            [T::Types::Simple.new(T::Struct), T::Types::Simple.new(Kernel)],
          )
        data = { type: intersection_type }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.unknown()')
        expect(result.discovered_classes).to be_empty
      end

      it 'handles T.class_of' do
        class_of_type = T::Types::ClassOf.new(String)
        data = { type: class_of_type }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.unknown()')
        expect(result.discovered_classes).to be_empty
      end

      xit 'handles T.attached_class' do
        # Skip: T::Types::AttachedClass might not be available in all Sorbet versions
        attached_type = T::Types::AttachedClass.new
        data = { type: attached_type }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.unknown()')
        expect(result.discovered_classes).to be_empty
      end

      it 'handles T.noreturn' do
        noreturn_type = T::Types::NoReturn.new
        data = { type: noreturn_type }
        result = converter.write_prop(data)
        expect(result.zod_definition).to eq('z.unknown()')
        expect(result.discovered_classes).to be_empty
      end
    end
  end
end
